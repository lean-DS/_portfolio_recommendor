# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12P31RQEZ5J3YFiv6GUTHhaIqMxJ5LcgU
"""

!pip install streamlit

# app.py
import os
import math
import time
from typing import Dict, List, Tuple

import streamlit as st
import pandas as pd
import numpy as np

# Optional, for ETF vol calc (last 60d)
import yfinance as yf

# -----------------------------
# Config
# -----------------------------
st.set_page_config(page_title="Portfolio Recommender", layout="wide")
DATA_DIR = os.getenv("DATA_DIR", "data")
MASTER_PQ = os.path.join(DATA_DIR, "sp500_master_features.parquet")
MASTER_CSV = os.path.join(DATA_DIR, "sp500_master_features.csv")
SECS_CSV = os.path.join(DATA_DIR, "securities.csv")

st.title("Dynamic Portfolio Recommender (S&P 500)")

# -----------------------------
# Utilities
# -----------------------------
def load_master() -> pd.DataFrame:
    """Load the per-day S&P500 master (adj_close, volume per date,ticker)."""
    if os.path.exists(MASTER_PQ):
        df = pd.read_parquet(MASTER_PQ)
    elif os.path.exists(MASTER_CSV):
        df = pd.read_csv(MASTER_CSV)
    else:
        st.error("Master features file not found. Add 'data/sp500_master_features.parquet' or '.csv' to the repo.")
        st.stop()
    # minimal columns required
    needed = {"date","ticker","adj_close","volume"}
    has = set(c.lower() for c in df.columns)
    if not needed.issubset(has):
        st.error("Master file must include columns: date, ticker, adj_close, volume.")
        st.stop()
    # normalize
    df = df.rename(columns=str.lower)
    df["date"] = pd.to_datetime(df["date"], errors="coerce")
    df = df.dropna(subset=["date","ticker","adj_close"]).sort_values(["ticker","date"]).reset_index(drop=True)
    df["ticker"] = df["ticker"].astype(str).str.upper().str.strip()
    return df

def load_secs() -> pd.DataFrame:
    if not os.path.exists(SECS_CSV):
        st.warning("securities.csv not found; will treat dividend_yield=0 and beta=None.")
        return pd.DataFrame(columns=["ticker","dividend_yield","beta"])
    df = pd.read_csv(SECS_CSV)
    df = df.rename(columns=str.lower)
    if "ticker" not in df.columns:
        st.error("securities.csv must include a 'ticker' column.")
        st.stop()
    for c in ["dividend_yield","beta"]:
        if c not in df.columns:
            df[c] = np.nan
    df["ticker"] = df["ticker"].astype(str).str.upper().str.strip()
    return df[["ticker","dividend_yield","beta"]].drop_duplicates("ticker")

def total_return(series: pd.Series, days: int) -> float:
    if len(series) <= days or series.iloc[-1 - days] == 0:
        return np.nan
    return float(series.iloc[-1] / series.iloc[-1 - days] - 1.0)

def max_drawdown(close: pd.Series) -> float:
    if close.empty:
        return np.nan
    roll_max = close.cummax()
    dd = (close / roll_max) - 1.0
    return float(dd.min()) if len(dd) else np.nan

def normalize(s: pd.Series, invert: bool = False) -> pd.Series:
    s = s.replace([np.inf, -np.inf], np.nan)
    if s.isna().all():
        out = pd.Series(0.5, index=s.index)
    else:
        s2 = s.fillna(s.median())
        lo, hi = float(s2.min()), float(s2.max())
        out = pd.Series(0.5, index=s.index) if hi == lo else (s2 - lo) / (hi - lo)
    return 1 - out if invert else out

def equity_weights(goal: str, horizon_years: int) -> Dict[str, float]:
    # Momentum (mom3/mom6/mom12), volatility (vol), drawdown (dd), yield, sentiment(omitted here)
    short = horizon_years < 3
    if goal == "Capital Growth":
        return {"mom3":0.35 if short else 0.25, "mom6":0.20, "mom12":0.15 if short else 0.25,
                "vol":0.10, "dd":0.10, "yield":0.00 if short else 0.05}
    if goal == "Dividend Income":
        return {"yield":0.55 if not short else 0.45, "vol":0.15, "dd":0.15,
                "mom3":0.05, "mom6":0.05, "mom12":0.05}
    # Balanced
    return {"mom3":0.20 if short else 0.15, "mom6":0.20, "mom12":0.20,
            "vol":0.15, "dd":0.15, "yield":0.05}

def recommend_risk_by_age(age: int) -> str:
    if age < 30: return "Aggressive"
    if age <= 45: return "Moderate"
    return "Conservative"

def beta_window(profile: str) -> Tuple[float, float]:
    if profile == "Conservative": return (0.5, 1.0)
    if profile == "Moderate":     return (1.1, 1.3)
    return (1.4, 2.2)

# Simple ETF pool; we’ll fetch 60d vol via yfinance at runtime
ETF_POOL = pd.DataFrame({
    "Ticker": [
        # short duration
        "SHV","BIL","SHY",
        # intermediate
        "IEI","GOVT","AGG","VGIT",
        # long
        "TLT","EDV",
        # sovereign/TIPS
        "TIP","SCHP",
        # IG corporate
        "LQD","VCIT",
        # high yield
        "HYG","JNK",
    ],
    "Name": [
        "iShares Short Treasury","SPDR Bloomberg 1-3M T-Bill","iShares 1-3Y Treasury",
        "iShares 3-7Y Treasury","iShares U.S. Treasury Bond","iShares Core U.S. Aggregate Bond","Vanguard Int-Term Treasury",
        "iShares 20+Y Treasury","Vanguard Ext Duration",
        "iShares TIPS","Schwab US TIPS",
        "iShares iBoxx IG Corporate","Vanguard Int-Term Corporate",
        "iShares High Yield Corporate","SPDR Bloomberg High Yield"
    ]
})

def etf_category_from_name(t: str, nm: str) -> str:
    x = f"{t} {nm}".lower()
    if any(k in x for k in ["ultra short","ultrashort","very short","t-bill","t bill","0-3","0-1","1-3","short-term","short term","short duration","shv","bil","shy"]):
        return "short_duration_bond"
    if any(k in x for k in ["intermediate","3-7","5-10","7-10","iei","govt","aggregate","agg","core","total bond","intermediate-term","vgit"]):
        return "intermediate_bond"
    if any(k in x for k in ["long-term","long term","long duration","20+","tlt","edv"]):
        return "long_duration_bond"
    if any(k in x for k in ["tips","inflation","treasury inflation"]):
        return "sovereign_bond"
    if any(k in x for k in ["corporate","credit","lqd","vcit","ig","investment grade"]):
        return "ig_corporate_bond"
    if any(k in x for k in ["high yield","junk","hyg","jnk"]):
        return "high_yield_bond"
    return "other_bond"

def etf_preference_weights(risk: str, goal: str, horizon_years: int) -> Dict[str, float]:
    short = horizon_years < 3
    if risk == "Conservative":
        base = {"short_duration_bond":0.40 if short else 0.30, "intermediate_bond":0.30 if short else 0.35,
                "sovereign_bond":0.20, "ig_corporate_bond":0.10,
                "long_duration_bond":0.00, "high_yield_bond":0.00, "other_bond":0.00}
    elif risk == "Moderate":
        base = {"short_duration_bond":0.20 if short else 0.15, "intermediate_bond":0.35,
                "sovereign_bond":0.15, "ig_corporate_bond":0.20,
                "long_duration_bond":0.05 if not short else 0.00,
                "high_yield_bond":0.05 if not short else 0.00, "other_bond":0.00}
    else:
        base = {"short_duration_bond":0.10 if short else 0.05, "intermediate_bond":0.25,
                "sovereign_bond":0.10, "ig_corporate_bond":0.25,
                "long_duration_bond":0.15 if not short else 0.05,
                "high_yield_bond":0.15 if not short else 0.05, "other_bond":0.00}

    if goal == "Dividend Income":
        base["ig_corporate_bond"] += 0.05
        base["high_yield_bond"] += (0.05 if not short else 0.02)
    elif goal == "Capital Growth":
        base["long_duration_bond"] += (0.05 if not short else 0.00)
        base["short_duration_bond"] -= (0.05 if not short else 0.00)

    s = sum(base.values()) or 1.0
    return {k: v/s for k, v in base.items()}

def etf_rank(risk: str, goal: str, horizon: int, want: int = 6) -> pd.DataFrame:
    df = ETF_POOL.copy()
    df["Category"] = [etf_category_from_name(t, n) for t, n in zip(df["Ticker"], df["Name"])]
    # Volatility (60d) via yfinance; if fail, leave NaN
    vols = []
    for t in df["Ticker"]:
        try:
            px = yf.download(t, period="90d", interval="1d", progress=False)
            ret = px["Close"].pct_change().dropna().tail(60)
            vols.append(float(ret.std()) if not ret.empty else np.nan)
            time.sleep(0.05)
        except Exception:
            vols.append(np.nan)
    df["Vol60"] = pd.to_numeric(pd.Series(vols), errors="coerce")
    prefs = etf_preference_weights(risk, goal, horizon)
    cat_score = df["Category"].map(prefs).fillna(0.0)
    vol_score = (1 - normalize(df["Vol60"])).fillna(0.5)
    df["Score"] = 0.65 * cat_score + 0.35 * vol_score
    return df.sort_values("Score", ascending=False).head(want).reset_index(drop=True)

# -----------------------------
# UI
# -----------------------------
c1, c2, c3, c4 = st.columns(4)
with c1:
    age = st.number_input("Age", min_value=18, max_value=100, value=30)
with c2:
    horizon = st.slider("Investment Horizon (years)", 1, 20, 5)
with c3:
    goal = st.selectbox("Strategy", ["Dividend Income", "Capital Growth", "Balanced"])
with c4:
    suggested = recommend_risk_by_age(age)
    risk = st.selectbox("Risk Appetite", ["Conservative","Moderate","Aggressive"],
                        index=["Conservative","Moderate","Aggressive"].index(suggested))
st.caption(f"Suggested by age rule: **{suggested}** (you can override)")

equity_pct = max(0, min(100, 100 - age))  # e.g., age 30 → 70% equity, 30% ETFs
etf_pct = 100 - equity_pct
st.info(f"**Allocation split** → Equities: **{equity_pct}%**, ETFs: **{etf_pct}%**")

# -----------------------------
# Build on click
# -----------------------------
if st.button("Build Portfolio", type="primary"):
    with st.spinner("Loading data and computing features..."):
        master = load_master()
        secs = load_secs()

        # Keep the last ~252 trading days per ticker for features
        def last_n_rows(g: pd.DataFrame, n: int = 260) -> pd.DataFrame:
            return g.tail(n)
        panel = master.groupby("ticker", group_keys=True).apply(last_n_rows).reset_index(drop=True)

        # Compute features per ticker
        feats = []
        for sym, g in panel.groupby("ticker"):
            close = g["adj_close"].astype(float)
            vol = g["volume"].astype(float)

            mom3  = total_return(close, 63)
            mom6  = total_return(close, 126)
            mom12 = total_return(close, 252)

            ret = close.pct_change().dropna()
            vol_sd = float(ret.std()) if not ret.empty else np.nan

            mdd = max_drawdown(close.tail(252))  # worst over last ~12m
            avgv60 = float(vol.tail(60).mean()) if len(vol) >= 10 else np.nan

            feats.append((sym, mom3, mom6, mom12, vol_sd, mdd, avgv60))

        eq = pd.DataFrame(feats, columns=["Ticker","3M Return","6M Return","12M Return","Volatility","Max Drawdown","AvgVol60"])
        eq["Ticker"] = eq["Ticker"].astype(str)

        # Attach dividend_yield and beta
        eq = eq.merge(secs[["ticker","dividend_yield","beta"]].rename(columns={"ticker":"Ticker"}), on="Ticker", how="left")
        eq["dividend_yield"] = pd.to_numeric(eq["dividend_yield"], errors="coerce").fillna(0.0)
        eq["beta"] = pd.to_numeric(eq["beta"], errors="coerce")

        # Beta window filter
        min_b, max_b = beta_window(risk)
        filtered = eq[eq["beta"].between(min_b, max_b, inclusive="both")]
        if len(filtered) < 25:
            # widen a bit if too restrictive
            filtered = eq[eq["beta"].between(min_b - 0.2, max_b + 0.2, inclusive="both")]

        # Scoring
        w = equity_weights(goal, horizon)
        score = (
            normalize(filtered["3M Return"])         * w.get("mom3",0) +
            normalize(filtered["6M Return"])         * w.get("mom6",0) +
            normalize(filtered["12M Return"])        * w.get("mom12",0) +
            normalize(filtered["Volatility"], True)  * w.get("vol",0) +
            normalize(filtered["Max Drawdown"], True)* w.get("dd",0) +
            normalize(filtered["dividend_yield"])    * w.get("yield",0)
        ).fillna(0.0)
        filtered = filtered.assign(Score=score).sort_values("Score", ascending=False)

        top_n = 20
        top_equities = filtered.head(top_n).reset_index(drop=True)

    st.subheader("Top 20 Equities (ranked for your profile)")
    st.dataframe(top_equities, use_container_width=True)

    # Position sizing within sleeves
    eq_weight_each = (equity_pct / 100.0) / max(1, len(top_equities))
    top_equities["Alloc_%"] = round(eq_weight_each * 100, 2)

    # ETFs
    with st.spinner("Selecting bond ETFs..."):
        top_etfs = etf_rank(risk, goal, horizon, want=6)
        if top_etfs.empty:
            st.warning("ETF ranking unavailable right now.")
        else:
            etf_weight_each = (etf_pct / 100.0) / len(top_etfs)
            top_etfs["Alloc_%"] = round(etf_weight_each * 100, 2)

    st.subheader("Suggested Allocation")
    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**Equities sleeve**")
        st.dataframe(top_equities[["Ticker","3M Return","6M Return","12M Return","Volatility","Max Drawdown","dividend_yield","beta","Score","Alloc_%"]],
                     use_container_width=True)
    with c2:
        st.markdown("**Bond ETF sleeve**")
        if not top_etfs.empty:
            st.dataframe(top_etfs[["Ticker","Category","Vol60","Score","Alloc_%"]], use_container_width=True)
        else:
            st.info("No ETF picks available (API hiccup).")

    st.success("Portfolio proposal generated.")